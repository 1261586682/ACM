摘要：

       莫队算法是一个对于区间、树或其他结构离线（在线）维护的算法，此算法基于一些基本算法，例如暴力维护，树状数组，分块，最小曼哈顿距离生成树，对其进行揉合从而产生的一个简单易懂且短小好写的算法。此算法在很多情况下可以很轻松的切掉一些复杂而且难写的数据结构问题。

关键词：

       程序设计、算法、算法优化，暴力算法，分块算法，最小曼哈顿距离生成树。

 

背景：

       众所周知，在OI竞赛、软件的设计中都会要求我们去处理各种各样的棘手的问题，而这些问题之中，有一大类就是维护问题：比如说对于一个序列的维护，对于棵二叉或者多叉树的维护……这些问题往往会需要我们去使用一个或多个高端的数据结构复合来完美解决，通常题目的代码十分冗长而且出错可能性十分大，是广大OIer、Acmer、Coder所害怕的题目。那么有没有一种方法可以既简单又快捷的解决这类问题（这类问题中的一大部分）呢？莫队算法就诞生辣！

理论1：

        序列莫队：我们现在有一个长为n的静态的序列，对于序列，我们有m次查询，我们要动态查询l到r之间大于a小于b的数的个数以及种类。遇到了这个问题我们通常需要使用书套树的数据结构，即一颗以自平衡二叉查找树为节点的线段树（时间复杂度大约是O(mlognlogn)），而且由于空间限制，我们还必须动态创建线段树的节点，这样一来十分难写，一些大约要个400-500行，调试起来也很困难。这时候我们来考虑暴力算法，如果暴力的处理题目中的问题那么复杂度是多少呢？这个不难计算，对于每个询问我们都要O(n)的时间处理,一共有m个询问，那么暴力处理的复杂度就是O(nm)的，明显处理问题花费的时间我们是不能接受的。这是我们想到可以交换询问和询问之间的先后次序，这样每次询问在前一次询问的基础上转移就可以节省一些时间了。

       但是如何重新排列询问之间的顺序是一个问题。我们需要进行一些理论分析。我们再上一个询问的基础上暴力地维护一个询问（假设上一个询问询问区间为[l0,r0]，这个询问区间为[l,r]），那么我们所谓的暴力维护就是先把现有答案的右边界从r0移动到r，再把左边界从l0移动到l，那么我们的总花费是O(|l-l0|+|r-r0|)。仔细看一看，没错，这就是我们的曼哈顿距离的计算公式，有了这个思路，我们就可以从图形的角度来思考了，对于一个询问[l,r]我们可以将它映射为平面上在(l,r)位置的点，那么两个询问之间转移的代价就是询问所对应的点之间的曼哈顿距离。有了这一个结论，我们便想到可以用最小曼哈顿生成树来处理询问的顺序。由此莫队算法便诞生啦！莫队算法就是先将询问抽象成平面上的点，然后进行一边最小曼哈顿距离生成树，然后按照生成树的顺序来处理询问，这样的算法复杂度大约是O(mSqrt(n))的。如此，问题便简单了许多。

       但是由于最小曼哈顿距离生成树也不是那么的好写，所以莫队算法还能再简单一点么？我们思考是否可以用一个简单而暴力的算法代替莫队算法呢。很快便能想到分块算法。我们可以使用分块算法来处理询问之间的次序问题。再去看那个询问对应的点所在的平面，我们找到它的X轴，我们把X轴平均分割成r分，然后我们把在一个块内的询问统一先处理，不在一个块内的询问我们按照左端点升序右端点升序排序依次处理。这样做有什么好处呢？对于m干个询问，如果在一个块里面，那么处理这些询问花费的复杂度是O(n/r*n*m)，如果有两个询问不在一个同一个块里面，按照我们之前的排序规则，我们把左区间和右区间在块之间移动的次数最多为r*(n/r)*r次，那么我们的复杂度就是O(r*(n/r)*r)次，经过简单的数学分析，我们可以发现r=Sqrt(n)是时间复杂度最低为O(nSqrt(n))次，是可以接受的时间复杂度。这样我们的莫队算法就又简单有强大了。但是在另一些情况下，题目会无耻的限定我们可以使用的空间（一般不会，因为这样高级数据结构的复合也难以解决这样的问题了）。那么如果空间被限定了，我们应该如何解决问题呢？其实很简单， 还记得我们之前的r么？我们为了求的时间复杂度最小令r=Sqrt(n),如果我们令r=n ^ (2 / 3)，那么便是一个时间复杂度和空间复杂度较为平衡的情况，这样可以很好的解决问题。

//https://blog.csdn.net/qq_41289920/article/details/82715231