例题：

       输入数据首先输入两个整数N,Q，分别代表序列的长度和询问的个数。这两个数字将单独占据一行并用一个空格分开。输入数据的第二行包含了N个由一个空格分开的正整数，代表了整个序列，从左向右依次编号为A1, A2……An。接下来Q行，每行两个整数i,j表示了一个询问区间。输入数据保证1≤i <j<=N

例题：

2038: [2009国家集训队]小Z的袜子(hose)

Description

       作为一个生活散漫的人，小Z每天早上都要耗费很久从一堆五颜六色的袜子中找出一双来穿。终于有一天，小Z再也无法忍受这恼人的找袜子过程，于是他决定听天由命……
       具体来说，小Z把这N只袜子从1到N编号，然后从编号L到R(L 尽管小Z并不在意两只袜子是不是完整的一双，甚至不在意两只袜子是否一左一右，他却很在意袜子的颜色，毕竟穿两只不同色的袜子会很尴尬。
你的任务便是告诉小Z，他有多大的概率抽到两只颜色相同的袜子。当然，小Z希望这个概率尽量高，所以他可能会询问多个(L,R)以方便自己选择。

Input

       输入文件第一行包含两个正整数N和M。N为袜子的数量，M为小Z所提的询问的数量。接下来一行包含N个正整数Ci，其中Ci表示第i只袜子的颜色，相同的颜色用相同的数字表示。再接下来M行，每行两个正整数L，R表示一个询问。

Output

       包含M行，对于每个询问在一行中输出分数A/B表示从该询问的区间[L,R]中随机抽出两只袜子颜色相同的概率。若该概率为0则输出0/1，否则输出的A/B必须为最简分数。（详见样例）

 

【样例解释】

询问1：共C(5,2)=10种可能，其中抽出两个2有1种可能，抽出两个3有3种可能，概率为(1+3)/10=4/10=2/5。

询问2：共C(3,2)=3种可能，无法抽到颜色相同的袜子，概率为0/3=0/1。

询问3：共C(3,2)=3种可能，均为抽出两个3，概率为3/3=1/1。

注：上述C(a, b)表示组合数，组合数C(a, b)等价于在a个不同的物品中选取b个的选取方案数。

【数据规模和约定】

30%的数据中 N,M ≤ 5000；

60%的数据中 N,M ≤ 25000；

100%的数据中 N,M ≤ 50000，1 ≤ L < R ≤ N，Ci ≤ N。

单个测试点时限2S

 

       对于上述这道题，30%的数据我们可以对于每个询问都扫描询问区间中所存在的数然后计算，这样单次复杂度是O(N)的，但有M的询问，总复杂度是O（MN）。这就显得有点不太能接受了。

但是当我们知道一个询问[l,r]的答案后，[l+1,r],[l-1,r],[l,r+1],[l,r-1]这四个区间的答案可以通过计算做到O(1)的时间内得到

所以我们可以考虑莫队算法，分为如下三步。

1、分块

2、把所有询问左端点排序

3、对于左端点在同一块内的询问按右端点排序，然后分三种情况统计。

而复杂度正如理论部分所说的一样，

一、i与i+1在同一块内，r单调递增，所以r是O(N)的。由于有sqrt(N)块,所以这一部分时间复杂度是Nsqrt(N)。
二、i与i+1跨越一块，r最多变化n，由于有sqrt(N)块，所以这一部分时间复杂度是Nsqrt(N)
三、i与i+1在同一块内时变化不超过sqrt(N)，跨越一块也不会超过2* sqrt(N)，不妨看作是sqrt(N)。由于有N个数，所以时间复杂度是O(Nsqrt(N))
可以证明复杂度是O(Nsqrt(N))了

 

理论2：

       可现在有很多问题都设置了修改操作，对于这类我们我们又该如何处理呢？

问题：

       我们现在有一个长为n的，对于序列，我们有m次操作，操作分为两种

1、询问在[l,r]中抽到两个数字相同的概率

2、把某个位置的数ai改成x

100%的数据中 N,M ≤100000，1 ≤ L < R ≤ N，Ci ≤ N。

单个测试点时限10S

我们会发现，加上了修改操作后。就没办法直接按照分块来处理解决询问的顺序。

定义B为分块的大小。

       首先考虑没有修改操作，那么就和理论1中小Z的袜子一样，令B = sqrt(n) 。把所有询问左端点排序，对于左端点在同一块内的询问按右端点排序,然后写莫队算法，按顺序扫询问，这样是O(n sqrt(n))。如果现在加上修改操作考虑一个询问(l,r)，这样是肯定不够的。

       于是变成：(l,r,ti)，ti是询问时的时间，即这次询问是第几次操作。把所有询问左端点l排序，对于左端点在同一块内的询问按右端点r所在的块排序，对右端点r所在块相同的我们再按照时间ti排序。

然后做莫队算法，按顺序扫询问，时间有时向前有时倒流。这样令B = n ^ (2 / 3)，因为在每一块中时间最多从1到T改变一次，设询问操作p1次，修改操作p2次，则在最差情况下的时间复杂度是O(p1 n^(2 / 3)+p2 *n^(1 / 3)* n^(1 / 3))=O(n^(5 / 3))【n与m等价】，这在时限下基本是可以得到答案的。

       那么还有个遗留的问题，如何处理时间。我们只需要记录修改前和修改后该点的值就可以了。

       至此这个问题完美解决。

总结：

       也许莫队是一种看起来复杂度非常高的算法，但如果合理地处理好分块的大小和询问的顺序，，它便可以变成一个极其有效的工具。